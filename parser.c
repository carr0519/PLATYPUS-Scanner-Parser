/*	File name:	parser.c
 *	Compiler:	MS Visual Studio 2019
 *	Author:		Alex Carrozzi
 *	Date:		November Decemeber 5, 2019
 *	Purpose:	Implements a recursive descent predictive parser for the PLATYPUS
 *				language using a combination of function calls for each 
 *				non-terminal and it's production as it's body. The parser calls 
 *				on the scanner to receive tokens (one at a time), and checks if 
 *				they are appear in a valid sequence (checking for syntactic correctness).
 *	
 *	Functions:	void match(int pr_token_code, int pr_token_attribute);
 *				void syn_eh(int sync_token_code);
 *				void syn_printe(void);
 *				void gen_incode(char* str);
 *				void parser(void);
 *				void program(void);
 *				void opt_statements(void);
 *				void statements(void);
 *				void statements_p(void);
 *				void statement(void);
 *				void assignment_statement(void);
 *				void selection_statement(void);
 *				void iteration_statement(void);
 *				void assignment_expression(void);
 *				void input_statement(void);
 *				void output_statement(void);
 *				void output_list(void);
 *				void opt_variable_list(void);
 *				void pre_condition(void);
 *				void variable_list(void);
 *				void variable_list_p(void);
 *				void variable_identifier(void);
 *				void relational_operator(void);
 *				void arithmetic_expression(void);
 *				void unary_arithmetic_expression(void);
 *				void additive_arithmetic_expression(void);
 *				void additive_arithmetic_expression_p(void);
 *				void multiplicative_arithmetic_expression(void);
 *				void multiplicative_arithmetic_expression_p(void);
 *				void primary_arithmetic_expression(void);
 *				void string_expression(void);
 *				void string_expression_p(void);
 *				void primary_string_expression(void);
 *				void conditional_expression(void);
 *				void logical_OR_expression(void);
 *				void logical_OR_expression_p(void);
 *				void logical_AND_expression(void);
 *				void logical_AND_expression_p(void);
 *				void relational_expression(void);
 *				void primary_a_relational_expression(void);
 *				void primary_s_relational_expression(void);
 */

#include <stdlib.h>
#include <stdio.h>

#include "parser.h"

/*	Purpose:	Attempts to match two terminals/tokens by their token code and maybe 
 *				their attribute as well. The two tokens are the one generated by  
 *				the scanner from the source file, and the other comes from the 
 *				production of some non-terminal which calls this function.
 *	Author:		Alex Carrozzi
 *	History / Versions:	1.0
 *	Called functions:	syn_eh(), malar_next_token(), syn_printe()
 *	Parameters:		pr_token_code: int, the token code of the token passed by the production
 *					pr_token_attribute: int, the token attribute of the token passed by the production
 *	Return value:	None
 *	Algorithm:		If the token from the production and the one from the scanner do not match, 
 *					the parser goes into a panic mode by calling syn_eh(). Otherwise, the token stream
 *					is advanced to the next token.
 */
void match(int pr_token_code, int pr_token_attribute)
{
	/* if the token codes don't match, PANIC */
	if (pr_token_code != lookahead.code) {
		syn_eh(pr_token_code);
		return;
	}

	/* EOF, all is well */
	if (pr_token_code == SEOF_T)
		return;

	/* attributes for the following tokens must also match */
	switch (pr_token_attribute) {
	case KW_T: case LOG_OP_T: case ART_OP_T: case REL_OP_T:
		if (lookahead.attribute.get_int != pr_token_attribute) {
			syn_eh(pr_token_code);
			return;
		}
		break;
	}

	/* tokens match, advance to the next input token
	   and check for if it's an error token */
	if ((lookahead = malar_next_token()).code == ERR_T) {
		syn_printe();
		lookahead = malar_next_token();
		++synerrno;
	}
}


/*	Purpose:	A simple panic mode error recovery. The parser will keep fetching 
 *				and discarding tokens from the scanner until the token code 
 *				matches the code passed in or until it reaches SEOF_T.
 *	Author:		Alex Carrozzi
 *	History / Versions:	1.0
 *	Called functions:	syn_printe(), malar_next_token(), exit()
 *	Parameters:		sync_token_code: int, the token code which is to be matched
 *	Return value:	None
 *	Algorithm:		see Purpose
 */
void syn_eh(int sync_token_code)
{
	syn_printe();
	++synerrno;

	/* keep getting tokens until a match is found or SEOF */
	while (lookahead.code != SEOF_T && (lookahead = malar_next_token()).code != sync_token_code)
		;

	/* EOF reached */
	if (sync_token_code == SEOF_T)
		return;
	
	/* End of token stream but the parser is expecting more */
	if (lookahead.code == SEOF_T)
		exit(synerrno);
	 
	/* the parser has recovered */
	lookahead = malar_next_token();
}


/*	Purpose:	An error printing function which display a syntax error message along with
				the token code and it's attribute (if relevant) from the scanner.
 *	History / Versions:	1.0
 *	Called functions:	printf()
 *	Parameters:		None
 *	Return value:	None
 *	Algorithm:		N/A
 */
void syn_printe(void) 
{
	Token t = lookahead;

	printf("PLATY: Syntax error:  Line:%3d\n", line);
	printf("*****  Token code:%3d Attribute: ", t.code);
	switch (t.code) {
	case  ERR_T: /* 0	Error token */
		printf("%s\n", t.attribute.err_lex);
		break;
	case  SEOF_T: /* 1	Source end-of-file token */
		printf("SEOF_T\t\t%d\t\n", t.attribute.seof);
		break;
	case  AVID_T: /* 2	Arithmetic Variable identifier token */
	case  SVID_T: /* 3	String Variable identifier token */
		printf("%s\n", t.attribute.vid_lex);
		break;
	case  FPL_T: /* 4	Floating point literal token */
		printf("%5.1f\n", t.attribute.flt_value);
		break;
	case INL_T: /* 5	Integer literal token */
		printf("%d\n", t.attribute.get_int);
		break;
	case STR_T: /* 6	String literal token */
		b_mark(str_LTBL, t.attribute.str_offset);
		printf("%s\n", b_location(str_LTBL));
		break;
	case SCC_OP_T: /* 7		String concatenation operator token */
		printf("NA\n");
		break;
	case  ASS_OP_T: /* 8	Assignment operator token */
		printf("NA\n");
		break;
	case  ART_OP_T: /* 9	Arithmetic operator token */
		printf("%d\n", t.attribute.get_int);
		break;
	case  REL_OP_T: /* 10	Relational operator token */
		printf("%d\n", t.attribute.get_int);
		break;
	case LOG_OP_T: /* 11	Logical operator token */
		printf("%d\n", t.attribute.get_int);
		break;
	case LPR_T: /* 12	Left parenthesis token */
		printf("NA\n");
		break;
	case RPR_T: /* 13	Right parenthesis token */
		printf("NA\n");
		break;
	case LBR_T: /* 14	Left brace token */
		printf("NA\n");
		break;
	case RBR_T: /* 15	Right brace token */
		printf("NA\n");
		break;
	case KW_T: /* 16	Keyword token */
		printf("%s\n", kw_table[t.attribute.get_int]);
		break;
	case COM_T: /* 17	Comma token */
		printf("NA\n");
		break;
	case EOS_T: /* 18	End of statement (semi-colon) */
		printf("NA\n");
		break;
	default:
		printf("PLATY: Scanner error: invalid token code: %d\n", t.code);
	}	/* end switch */
}	/* end syn_printe() */


/*	Purpose:	Prints the string passed in. The string should be in the form:
				"PLATY: [production] parsed", where production is one of the 
				non-terminals just before returning from the function.
 *	Author:		Alex Carrozzi
 *	History / Versions:	1.0
 *	Called functions:	puts()
 *	Parameters:		msg: char*, the string containing the message to print
 *	Return value:	None
 *	Algorithm:		N/A
 */
void gen_incode(char* msg) 
{
	puts(msg);
}


/*	Purpose:	Initiates the parsing process. Retrieves the first token from 
 *				the scanner and then calls the start symbol function program()
 *	History / Versions:	1.0
 *	Called functions:	malar_next_token(), program(), match(), gen_incode()
 *	Parameters:		None
 *	Return value:	None
 *	Algorithm:		N/A
 */
void parser(void)
{
	lookahead = malar_next_token();
	program(); match(SEOF_T, NO_ATTR);
	gen_incode("PLATY: Source file parsed");
}


/* --------------------------------------------------------------------- */
/* --------------------------------------------------------------------- */

/* -----------------------  BEGIN PRODUCTIONS  ------------------------- */

/* --------------------------------------------------------------------- */
/* --------------------------------------------------------------------- */


/*	<program> ->
 *	  PLATYPUS { <opt_statements> }
 *
 *	FIRST (<program>) = { KW_T(PLATYPUS) }
 */
void program(void)
{
	match(KW_T, PLATYPUS);
	match(LBR_T, NO_ATTR); 
	opt_statements();	
	match(RBR_T, NO_ATTR);
	gen_incode("PLATY: Program parsed");
}


/*	<opt_statements> ->
 *		  <statements>
 *		| empty
 *
 *	FIRST (<opt_statements>) = { AVID_T, SVID_T, KW_T(IF), KW_T(WHILE),
 *								 KW_T(READ), KW_T(WRITE), empty 
 */
void opt_statements(void) 
{
	switch (lookahead.code) {
	case AVID_T: case SVID_T:
		statements(); break;
	case KW_T:
		/* check for IF, WHILE, READ, WRITE in statements_p() */
		if (lookahead.attribute.get_int == IF
			|| lookahead.attribute.get_int == WHILE
			|| lookahead.attribute.get_int == READ
			|| lookahead.attribute.get_int == WRITE) {
			statements();
			break;
		}
	default: /* empty string Â– optional statements */;
		gen_incode("PLATY: Opt_statements parsed");
	}
}


/*	<statements> ->
 *		  <statement> 
 *		| <statements> <statement>
 *
 *	Modified: re-arranged the alternation and removed the left recursion
 *	
 *	<statements> ->
 *		<statement> <statements_p>
 *
 *	FIRST (<statements>) = { AVID_T, SVID_T, KW_T(IF), KW_T(WHILE), KW_T(READ), KW_T(WRITE) }
 */
void statements(void)
{
	statement(); 
	statements_p();
}


/*	<statements_p> ->
 *		  <statement> <statements_p>  
 *		| empty
 *
 *	FIRST (<statements_p>) = { AVID_T, SVID_T, KW_T(IF), KW_T(WHILE), KW_T(READ), KW_T(WRITE), empty }
 */
void statements_p(void) 
{
	switch (lookahead.code) {
	case AVID_T: case SVID_T: 
		statement();
		statements_p();
		break;
	case KW_T:
		switch (lookahead.attribute.kwt_idx) {
			case IF: case WHILE: case READ: case WRITE:
				statement(); 
				statements_p(); 
				break;
		}
		break;
	}
}


/*	<statement> ->
 *		  <assignment_statement>
 *		| <selection_statement>
 *		| <iteration_statement>
 *		| <input_statement>
 *		| <output_statement>
 *
 *	FIRST (<statement>) = { AVID_T, SVID_T, KW_T(IF), KW_T(WHILE), KW_T(READ), KW_T(WRITE) }
 */
void statement(void)
{
	switch (lookahead.code) {
	case AVID_T: case SVID_T:
		assignment_statement(); break;
	case KW_T:
		switch (lookahead.attribute.kwt_idx) {
		case IF:	selection_statement(); break;
		case WHILE: iteration_statement(); break;
		case READ:	input_statement();	   break;
		case WRITE:	output_statement();    break;
		default:	syn_printe();		   return;
		}
		break;
	default: /* empty string not an option here - print error */
		syn_printe(); return;
	}
}


/*	<assignment_statement > ->
 *		<assignment_expression> ;
 *
 *	FIRST (<assignment_statement>) = { AVID_T, SVID_T }
 */
void assignment_statement(void)
{
	assignment_expression(); 
	match(EOS_T, NO_ATTR);
	gen_incode("PLATY: Assignment statement parsed");
}


/*	<selection_statement> ->
 *		IF <pre_condition> ( <conditional expression> )
 *		THEN { <opt_statements> } ELSE { <opt_statements> } ;
 *
 *	FIRST (<selection statement>) = { KW_T(IF) }
 */
void selection_statement(void) 
{
	match(KW_T, IF); pre_condition(); match(LPR_T, NO_ATTR);
	conditional_expression(); match(RPR_T, NO_ATTR);
	match(KW_T, THEN); match(LBR_T, NO_ATTR);
	opt_statements(); match(RBR_T, NO_ATTR); match(KW_T, ELSE);
	match(LBR_T, NO_ATTR); opt_statements();
	match(RBR_T, NO_ATTR); match(EOS_T, NO_ATTR);
	gen_incode("PLATY: Selection statement parsed");
}


/*	<iteration_statement> ->
 *		WHILE <pre_condition> ( <conditional_expression> ) REPEAT { <statements> } ;
 *
 *	FIRST (<iteration_statement>) = { KW_T(WHILE) }
 */
void iteration_statement(void)
{	
	match(KW_T, WHILE); pre_condition(); match(LPR_T, NO_ATTR);
	conditional_expression(); match(RPR_T, NO_ATTR);
	match(KW_T, REPEAT); match(LBR_T, NO_ATTR); statements();
	match(RBR_T, NO_ATTR); match(EOS_T, NO_ATTR);
	gen_incode("PLATY: Iteration statement parsed");
}


/*	<assignment_expression>  ->
 *		  AVID_T = <arithmetic_expression>
 *		| SVID_T = <string_expression>
 *
 *	FIRST (<assignment_expression>) = { AVID_T, SVID_T }
 */
void assignment_expression(void) 
{	
	if (lookahead.code == AVID_T) {
		match(AVID_T, NO_ATTR); 
		match(ASS_OP_T, NO_ATTR); 
		arithmetic_expression();
		gen_incode("PLATY: Assignment expression (arithmetic) parsed");
	}
	else if (lookahead.code == SVID_T) {
		match(SVID_T, NO_ATTR); 
		match(ASS_OP_T, NO_ATTR); 
		string_expression();
		gen_incode("PLATY: Assignment expression (string) parsed");
	}
	else /* empty string not an option here - print error */
		syn_printe();
}


/*	<input_statement>  ->
 *		READ ( <variable_list> ) ;
 *
 *  FIRST (<input_statement>) = { KW_T(READ) }
 */
void input_statement(void) 
{
	match(KW_T, READ); match(LPR_T, NO_ATTR);
	variable_list();
	match(RPR_T, NO_ATTR); match(EOS_T, NO_ATTR);
	gen_incode("PLATY: Input statement parsed");
}


/*	<output_statement> ->
 *		  WRITE ( <opt_variable_list> ) ;
 *		| WRITE ( STR_T ) ; 
 *
 *	Modified: non-predictability removed by replacing the 
			  arguments with a new non-terminal <output_list>
 *
 *	<output_statement>  ->
 *		WRITE ( <output_list> ) ;
 *
 *	FIRST (<output_statement>) = { KW_T(WRITE) }
 */
void output_statement(void)
{
	match(KW_T, WRITE); 
	match(LPR_T, NO_ATTR);
	output_list(); 
	match(RPR_T, NO_ATTR);
	match(EOS_T, NO_ATTR);
	gen_incode("PLATY: Output statement parsed");
}


/*	<output_list> ->
 *		  <opt_variable_list>
 *		| STR_T
 *
 *	FIRST (<output_list>) = { SVID_T, AVID_T, STR_T, empty }
 */
void output_list(void) 
{
	if (lookahead.code == STR_T) {
		match(STR_T, NO_ATTR);
		gen_incode("PLATY: Output list (string literal) parsed");
	}
	else if (lookahead.code == SVID_T || lookahead.code == AVID_T)
		opt_variable_list();
	else /* empty string is valid in this production */
		gen_incode("PLATY: Output list (empty) parsed");
}


/*	<opt_variable_list> ->
 *		  <variable_list>
 *		| empty
 *
 *  FIRST (<opt_variable_list>) = { SVID_T , AVID_T , empty }
 */
void opt_variable_list(void) 
{
	if (lookahead.code == AVID_T || lookahead.code == SVID_T)
		variable_list();
}


/*	<pre_condition> ->
 *		  TRUE
 *		| FALSE
 *
 *	FIRST(<pre_condition>) = { KW_T(TRUE), KW_T(FALSE) }
 */
void pre_condition(void) 
{
	if (lookahead.code == KW_T &&
		lookahead.attribute.kwt_idx == TRUE)
		match(KW_T, TRUE);
	else if (lookahead.code == KW_T && 
			 lookahead.attribute.kwt_idx == FALSE)
		match(KW_T, FALSE);
	else /* empty string not an option here - print error */
		syn_printe();
}


/*	<variable_list> ->
 *		  <variable_identifier>
 *		| <variable_list> , <variable_identifier>
 *
 *	Modified: re-arranged alternation and removed left recursion
 *
 *	<variable_list> ->
 *		<variable_identifier> <variable_list_p>
 *
 *  FIRST (<variable_list>) = { SVID_T, AVID_T }
 */
void variable_list(void) 
{
	variable_identifier();
	variable_list_p();
	gen_incode("PLATY: Variable list parsed");
}


/*	<variable_list_p> ->
 *	      , <variable_identifier> <variable_list_p>
 *		| empty
 *
 *  FIRST (<variable_list_p>) = { COM_T, empty }
 */
void variable_list_p(void) 
{
	if (lookahead.code == COM_T) {
		match(COM_T, NO_ATTR);
		variable_identifier();
		variable_list_p();
	}
}


/*	<variable_identifier> ->
 *		  <arithmetic_variable_identifier>
 *		| <string_variable_identifier>
 *
 *	Modified: <arithmetic_variable_identifier> and <string_variable_identifier>
			  replaced by their token equivalents.
 *
 *	 <variable_identifier> ->
 *		  SVID_T
 *		| AVID_T
 *
 *  FIRST (<variable_identifier>) = { SVID_T, AVID_T }
 */
void variable_identifier(void)
{
	if (lookahead.code == AVID_T)
		match(AVID_T, NO_ATTR);
	else if (lookahead.code == SVID_T)
		match(SVID_T, NO_ATTR);
	else /* empty string not an option here - print error */
		syn_printe();
}


/*	<relational_operator> ->
 *		>  |  <  |  == |  <>  
 *
 *  FIRST (<relational_operator>) = { REL_OP_T(>), REL_OP_T(<), REL_OP_T(==), REL_OP_T(<>) }
 */
void relational_operator(void) 
{
	if (lookahead.code == REL_OP_T)
		match(REL_OP_T, lookahead.attribute.rel_op);
	else /* empty string not an option here - print error */
		syn_printe();
}


/*	<arithmetic_expression> ->
 *		  <unary_arithmetic_expression>  
 *		| <additive_arithmetic_expression>	
 *
 *	FIRST (<arithmetic_expression>) = { ART_OP_T(PLUS), ART_OP_T(MINUS), AVID_T, FPL_T, INL_T, LPR_T }
 */
void arithmetic_expression(void)
{
	switch (lookahead.code) {
	case ART_OP_T:
		if (lookahead.attribute.arr_op == PLUS
			|| lookahead.attribute.arr_op == MINUS) {
			unary_arithmetic_expression();
			gen_incode("PLATY: Arithmetic expression parsed");
		}
		else /* empty string not an option here - print error */
			syn_printe();
		break;
	case AVID_T: case FPL_T: case INL_T: case LPR_T: 
		additive_arithmetic_expression();
		gen_incode("PLATY: Arithmetic expression parsed");
		break;
	default: /* empty string not an option here - print error */
		syn_printe();
	}
}


/*	<unary_arithmetic_expression> ->
 *		  -  <primary_arithmetic_expression> 
 *		| + <primary_arithmetic_expression>
 *
 *  FIRST (<unary_arithmetic_expression>) = { ART_OP_T(PLUS), ART_OP_T(MINUS) }
 */
void unary_arithmetic_expression(void) 
{
	switch (lookahead.code) {
	case ART_OP_T:
		switch(lookahead.attribute.arr_op) {
		case PLUS:
			match(ART_OP_T, PLUS);
			break;
		case MINUS:
			match(ART_OP_T, MINUS);
			break;
		default:
			syn_printe();
			return;
		}
		break;
	default: /* empty string not an option here - print error */
		syn_printe();
		return;
	}
	primary_arithmetic_expression();
	gen_incode("PLATY: Unary arithmetic expression parsed");
}


/*	<additive_arithmetic_expression> ->
 *		  <additive_arithmetic_expression> + <multiplicative_arithmetic_expression>
 *		| <additive_arithmetic_expression> - <multiplicative_arithmetic_expression>
 *		| <multiplicative_arithmetic_expression>
 *
 *	Modified: eliminated left recursion and non-predictability
 *
 *	<additive_arithmetic_expression> ->
 *		<multiplicative_arithmetic_expression> <additive_arithmetic_expression_p>
 *
 *  FIRST (<additive_arithmetic_expression>) = { AVID_T, FPL_T, INL_T, LPR_T }
 */
void additive_arithmetic_expression(void) 
{
	multiplicative_arithmetic_expression();
	additive_arithmetic_expression_p();
}


/*	<additive_arithmetic_expression_p> ->
 *		  + <multiplicative_arithmetic_expression> <additive_arithmetic_expression_p>
 *		| - <multiplicative_arithmetic_expression> <additive_arithmetic_expression_p>
 *		| empty
 *
 *	FIRST (<additive_arithmetic_expression_p>) = { ART_OP_T(PLUS), ART_OP_T(MINUS), empty }
 */
void additive_arithmetic_expression_p(void)
{
	if (lookahead.code == ART_OP_T)
		if (lookahead.attribute.arr_op == PLUS) {
			match(ART_OP_T, PLUS);
			multiplicative_arithmetic_expression();
			additive_arithmetic_expression_p();
			gen_incode("PLATY: Additive arithmetic expression parsed");
		}
		else if (lookahead.attribute.arr_op == MINUS) {
			match(ART_OP_T, MINUS); 
			multiplicative_arithmetic_expression();
			additive_arithmetic_expression_p();
			gen_incode("PLATY: Additive arithmetic expression parsed");
		}
}


/*	<multiplicative_arithmetic_expression> ->
 *		  <multiplicative_arithmetic_expression> * <primary_arithmetic_expression>
 *		| <multiplicative_arithmetic_expression> / <primary arithmetic_expression>
 *		| <primary_arithmetic_expression>
 *
 *	Modified: eliminated left recursion and non-predictability
 *
 *	<multiplicative_arithmetic_expression> ->
 *		<primary_arithmetic_expression> <multiplicative_arithmetic_expression_p>
 *
 *	FIRST (<multiplicative_arithmetic_expression>) = { AVID_T, FPL_T, INL_T, LPR_T }
 */
void multiplicative_arithmetic_expression(void)
{
	primary_arithmetic_expression();
	multiplicative_arithmetic_expression_p();
}


/*	<multiplicative_arithmetic_expression_p> ->
 *		  * <primary_arithmetic_expression> <multiplicative_arithmetic_expression_p>
 *		| / <primary_arithmetic_expression> <multiplicative_arithmetic_expression_p>
 *		| empty
 *	
 *	FIRST (<multiplicative arithmetic expression_p>) = { ART_OP_T(MULT), ART_OP_T(DIV), empty }
 */
void multiplicative_arithmetic_expression_p(void)
{
	if (lookahead.code == ART_OP_T) 
		if (lookahead.attribute.arr_op == MULT) {
			match(ART_OP_T, MULT);
			primary_arithmetic_expression();
			multiplicative_arithmetic_expression_p();
			gen_incode("PLATY: Multiplicative arithmetic expression parsed");
		}
		else if (lookahead.attribute.arr_op == DIV) {
			match(ART_OP_T, DIV);
			primary_arithmetic_expression();
			multiplicative_arithmetic_expression_p();
			gen_incode("PLATY: Multiplicative arithmetic expression parsed");
		}
}


/*	<primary_arithmetic_expression> ->
 *		  AVID_T
 *		| FPL_T
 *		| INL_T
 *		| ( <arithmetic_expression> )
 *
 *  FIRST (<primary_arithmetic_expression>) = { AVID_T, FPL_T, INL_T, LPR_T }
 */
void primary_arithmetic_expression(void)
{
	switch (lookahead.code) {
	case AVID_T: case FPL_T: case INL_T:
		match(lookahead.code, NO_ATTR);
		break;
	case LPR_T:
		match(LPR_T, NO_ATTR);
		arithmetic_expression();
		match(RPR_T, NO_ATTR);
		break;
	default: /* empty string not an option here - print error */
		syn_printe(); 
		return;
	}
	gen_incode("PLATY: Primary arithmetic expression parsed");
}


/*	string_expression> ->
 *		  <primary_string_expression>
 *		| <string_expression> << <primary_string_expression>
 *
 *	Modified: re-arranged the alternation and removed left recursion
 *
 *	<string_expression> ->
 *		<primary_string_expression> <string_expression_p>
 *
 *  FIRST (<string expression>) = { SVID_T, STR_T }
 */
void string_expression(void)
{
	primary_string_expression();
	string_expression_p();
	gen_incode("PLATY: String expression parsed");
}


/*	<string_expression_p> ->
 *		  << <primary_string_expression> <string_expression_p>
 *		| empty
 *	
 *	FIRST (<string expression_p>) = { SCC_OP_T, empty }
 */
void string_expression_p(void)
{
	if (lookahead.code == SCC_OP_T) {
		match(SCC_OP_T, NO_ATTR);
		primary_string_expression();
		string_expression_p();
	}
}


/*	<primary_string_expression> ->
 *		  SVID_T
 *		| STR_T
 *
 *  FIRST (<primary_string_expression>) = { SVID_T, STR_T } 
 */
void primary_string_expression(void)
{
	switch (lookahead.code) {
	case SVID_T:
		match(SVID_T, NO_ATTR);
		break;
	case STR_T:
		match(STR_T, NO_ATTR);
		break;
	default: /* empty string not an option here - print error */
		syn_printe(); 
		return;
	}
	gen_incode("PLATY: Primary string expression parsed");
}


/*	<conditional_expression> ->
 *		<logical_OR_expression>
 *
 *	FIRST (<conditional_expression>) = { AVID_T, FPL_T, INL_T, SVID_T, STR_T }
 */
void conditional_expression(void)
{
	logical_OR_expression();
	gen_incode("PLATY: Conditional expression parsed");
}


/*	<logical_OR_expression> ->
 *		  <logical_AND_expression>
 *		| <logical_OR_expression> .OR. <logical_AND_expression>
 *
 *	Modified: re-arranged the alternation and removed left recursion
 *
 *	<logical_OR_expression> ->
 *		<logical_AND_expression> <logical_OR_expression_p>
 *
 *	FIRST (<logical_OR_expression>) = { AVID_T, FPL_T, INL_T,  SVID_T, STR_T }
 */
void logical_OR_expression(void)
{
	logical_AND_expression();
	logical_OR_expression_p();
}


/*	<logical_OR_expression_p> ->
 *		  .OR. <logical_AND_expression> <logical_OR_expression_p>
 *		| empty
 *	
 *	FIRST (<logical_OR_expression_p>) = { LOG_OP_T(.OR.), empty }
 */
void logical_OR_expression_p(void)
{
	if (lookahead.code == LOG_OP_T && lookahead.attribute.log_op == OR) {
		match(LOG_OP_T, OR);
		logical_AND_expression();
		logical_OR_expression_p();
		gen_incode("PLATY: Logical OR expression parsed");
	}
}


/*	<logical_AND_expression> ->
 *		  <relational_expression>
 *		| <logical_AND_expression> .AND. <relational_expression>
 *
 *	Modified: re-arranged the alternation and removed left recursion
 *
 *	<logical_AND_expression> ->
 *		<relational_expression> <logical_AND_expression_p>
 *
 *	FIRST (<logical_AND_expression>) = { AVID_T, FPL_T, INL_T,  SVID_T, STR_T }
 */
void logical_AND_expression(void)
{
	relational_expression();
	logical_AND_expression_p();
}


/*	<logical_AND_expression_p> ->
 *		  .AND. <relational_expression> <logical_AND_expression_p>
 *		| empty
 *
 *	FIRST (<logical_AND_expression_p>) = { LOG_OP_T(.AND.), empty }
 */
void logical_AND_expression_p(void)
{
	if (lookahead.code == LOG_OP_T && lookahead.attribute.log_op == AND) {
		match(LOG_OP_T, AND);
		relational_expression();
		logical_AND_expression_p();
		gen_incode("PLATY: Logical AND expression parsed");
	}
}


/*	<relational_expression> ->
 *		  <primary_a_relational_expression>  ==  <primary_a_relational_expression>
 *		| <primary_a_relational_expression>  <>  <primary_a_relational_expression>
 *		| <primary_a_relational_expression>  >   <primary_a_relational_expression>
 *		| <primary_a_relational_expression>  <   <primary_a_relational_expression>
 *		| <primary_s_relational_expression>  ==  <primary_s_relational_expression>
 *		| <primary_s_relational_expression>  <>  <primary_s_relational_expression>
 *		| <primary_s_relational_expression>  >   <primary_s_relational_expression>
 *		| <primary_s_relational_expression>  <   <primary_s_relational_expression>
 *
 *	Modified: relational operators replaced by the non-terminal <relational_operator>
 *
 *	<relational_expression> ->
 *		  <primary_a_relational_expression> <relational_operator> <primary_a_relational_expression>
 *		| <primary_s_relational_expression> <relational_operator> <primary_s_relational_expression>
 *
 *  FIRST (<relational_expression>) = { AVID_T, FPL_T, INL_T, SVID_T, STR_T }
 */
void relational_expression(void)
{
	switch (lookahead.code) {
	case AVID_T: case FPL_T: case INL_T:
		primary_a_relational_expression();
		relational_operator();
		primary_a_relational_expression();
		break;
	case SVID_T: case STR_T:
		primary_s_relational_expression();
		relational_operator();
		primary_s_relational_expression();
		break;
	default: /* empty string not an option here - print error */
		syn_printe(); 
	}
	gen_incode("PLATY: Relational expression parsed");
}


/*	<primary_a_relational_expression> ->
 *		  AVID_T
 *		| FPL_T
 *		| INL_T
 *
 *	FIRST (<primary_a_relational_expression>) = { AVID_T, FPL_T, INL_T }
 */
void primary_a_relational_expression(void)
{
	switch (lookahead.code) {
	case AVID_T: case FPL_T: case INL_T:
		match(lookahead.code, NO_ATTR);
		break;
	default: /* empty string not an option here - print error */
		syn_printe();
	}
	gen_incode("PLATY: Primary a_relational expression parsed");
}


/*	<primary_s_relational_expression> ->
 *		<primary_string_expression>
 *
 *	FIRST (<primary_s_relational_expression>) = { SVID_T, STR_T }
 */
void primary_s_relational_expression(void)
{
	primary_string_expression();
	gen_incode("PLATY: Primary s_relational expression parsed");
}
